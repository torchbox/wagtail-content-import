{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Wagtail Content Import's Documentation Wagtail Content Import is a module for importing page content into Wagtail from third-party sources. Page content is imported into a StreamField, using a set of customisable mappings. Currently supports: As sources: Google Docs: OneDrive/SharePoint As files: Google Docs documents with: Rich text Tables Images Headings Docx files with: Text with bold and italics Headings","title":"Home"},{"location":"#welcome-to-wagtail-content-imports-documentation","text":"Wagtail Content Import is a module for importing page content into Wagtail from third-party sources. Page content is imported into a StreamField, using a set of customisable mappings. Currently supports:","title":"Welcome to Wagtail Content Import's Documentation"},{"location":"#as-sources","text":"Google Docs: OneDrive/SharePoint","title":"As sources:"},{"location":"#as-files","text":"Google Docs documents with: Rich text Tables Images Headings Docx files with: Text with bold and italics Headings","title":"As files:"},{"location":"basic_usage/","text":"Basic Usage To enable import for a Page model, it should inherit from ContentImportMixin ( wagtail_content_import.models.ContentImportMixin ). By default, content will be imported into into a StreamField called body (see Changing Import Fields for how to change this). You'll then need to create a Mapper, which maps the parsed document into your StreamField blocks. Create a class deriving from wagtail_content_import.mappers.streamfield.StreamFieldMapper : from wagtail_content_import.mappers.converters import ImageConverter , RichTextConverter , TableConverter , TextConverter from wagtail_content_import.mappers.streamfield import StreamFieldMapper class MyMapper ( StreamFieldMapper ): html = RichTextConverter ( 'my_paragraph_block' ) image = ImageConverter ( 'my_image_block' ) heading = TextConverter ( 'my_heading_block' ) table = TableConverter ( 'my_table_block' ) This would map to an example StreamField defined as: from wagtail.images.blocks import ImageChooserBlock from wagtail.core.blocks import CharBlock , RichTextBlock , StreamBlock from wagtail.contrib.table_block.blocks import TableBlock class BaseStreamBlock ( StreamBlock ): \"\"\" Define the custom blocks that `StreamField` will utilize \"\"\" my_heading_block = CharBlock () my_paragraph_block = RichTextBlock () my_image_block = ImageChooserBlock () my_table_block = TableBlock () Note that the converters require the fields rather than the block classes: 'my_heading_block' , not CharBlock . The above example assumes use of the simple blocks included with Wagtail. For StructBlocks, see Working with StructBlocks . Set mapper_class on your Page model to your new mapper class (or set WAGTAILCONTENTIMPORT_DEFAULT_MAPPER to your mapper use it for all imports by default). You should now see a button near the action menu when creating a new Page of your class in the admin, giving you the option to import a document.","title":"Basic Usage"},{"location":"basic_usage/#basic-usage","text":"To enable import for a Page model, it should inherit from ContentImportMixin ( wagtail_content_import.models.ContentImportMixin ). By default, content will be imported into into a StreamField called body (see Changing Import Fields for how to change this). You'll then need to create a Mapper, which maps the parsed document into your StreamField blocks. Create a class deriving from wagtail_content_import.mappers.streamfield.StreamFieldMapper : from wagtail_content_import.mappers.converters import ImageConverter , RichTextConverter , TableConverter , TextConverter from wagtail_content_import.mappers.streamfield import StreamFieldMapper class MyMapper ( StreamFieldMapper ): html = RichTextConverter ( 'my_paragraph_block' ) image = ImageConverter ( 'my_image_block' ) heading = TextConverter ( 'my_heading_block' ) table = TableConverter ( 'my_table_block' ) This would map to an example StreamField defined as: from wagtail.images.blocks import ImageChooserBlock from wagtail.core.blocks import CharBlock , RichTextBlock , StreamBlock from wagtail.contrib.table_block.blocks import TableBlock class BaseStreamBlock ( StreamBlock ): \"\"\" Define the custom blocks that `StreamField` will utilize \"\"\" my_heading_block = CharBlock () my_paragraph_block = RichTextBlock () my_image_block = ImageChooserBlock () my_table_block = TableBlock () Note that the converters require the fields rather than the block classes: 'my_heading_block' , not CharBlock . The above example assumes use of the simple blocks included with Wagtail. For StructBlocks, see Working with StructBlocks . Set mapper_class on your Page model to your new mapper class (or set WAGTAILCONTENTIMPORT_DEFAULT_MAPPER to your mapper use it for all imports by default). You should now see a button near the action menu when creating a new Page of your class in the admin, giving you the option to import a document.","title":"Basic Usage"},{"location":"changing_import_fields/","text":"To change how the document's data is imported to the Page model - for example, importing to a StreamField other than body , you'll need to override the update_from_import method. On the ContentImportMixin , these are defined as: from django.utils.text import slugify class ContentImportMixin : # ... # Called whenever a page is created or updated from an import # (note, when creating, self would be unsaved) def update_from_import ( self , parsed_doc , user ): self . title = parsed_doc [ \"title\" ] self . slug = slugify ( self . title ) mapper = self . mapper_class () self . body = mapper . map ( parsed_doc [ \"elements\" ], user = user ) To import into a different field, replace body with the name of your custom field.","title":"Changing Import Fields"},{"location":"converter_reference/","text":"Converters Converters are callable classes, which when called, take elements of the intermediate {'type': type, 'value': value} format (and keyword arguments) and return streamfield-compatible tuples of the (block_name, block_content) form. All converters inherit from wagtail_content_import.mappers.converters.BaseConverter , and take a block_name on init. RichTextConverter(block_name, features=None) Produces Draftail-compatible html suitable for a RichTextBlock , using either the features listed in features or the basic rich text features registered in the Wagtail feature registry (see the Wagtail documentation ). TextConverter(block_name) Passes the element's value field directly through as the block content. Note that this must be escaped, as no whitelisting takes place. ImageConverter(block_name) Imports an image found at the url given by the element's value , setting the title to the element's title if given, and the owner to the user kwarg if provided on calling, and returns the image as the block content. TableConverter(block_name) Produces a text table from the intermediate table representation, compatible with wagtail.contrib.table_block.blocks.TableBlock .","title":"Converters"},{"location":"converter_reference/#converters","text":"Converters are callable classes, which when called, take elements of the intermediate {'type': type, 'value': value} format (and keyword arguments) and return streamfield-compatible tuples of the (block_name, block_content) form. All converters inherit from wagtail_content_import.mappers.converters.BaseConverter , and take a block_name on init.","title":"Converters"},{"location":"converter_reference/#richtextconverterblock_name-featuresnone","text":"Produces Draftail-compatible html suitable for a RichTextBlock , using either the features listed in features or the basic rich text features registered in the Wagtail feature registry (see the Wagtail documentation ).","title":"RichTextConverter(block_name, features=None)"},{"location":"converter_reference/#textconverterblock_name","text":"Passes the element's value field directly through as the block content. Note that this must be escaped, as no whitelisting takes place.","title":"TextConverter(block_name)"},{"location":"converter_reference/#imageconverterblock_name","text":"Imports an image found at the url given by the element's value , setting the title to the element's title if given, and the owner to the user kwarg if provided on calling, and returns the image as the block content.","title":"ImageConverter(block_name)"},{"location":"converter_reference/#tableconverterblock_name","text":"Produces a text table from the intermediate table representation, compatible with wagtail.contrib.table_block.blocks.TableBlock .","title":"TableConverter(block_name)"},{"location":"custom_converters/","text":"Converters are callable classes which convert {type: type, 'value': value} elements in a parsed document to StreamField blocks. You can write your own custom converters to include functionality not in the core app: for example, working with StructBlocks . Converters should inherit from wagtail_content_import.mappers.converters.BaseConverter , which provides an __init__ method which populates self.block_name , the field name of the StreamField block the converter is creating. Converters should implement a __call__(self, element, **kwargs) method which returns a StreamField-compatible tuple of (self.block_name, content) for an element of the form {type: type, 'value': value} For example, the default TextConverter is implemented simply as: from wagtail_content_import.parsers.converters import BaseConverter class TextConverter ( BaseConverter ): def __call__ ( self , element , ** kwargs ): return ( self . block_name , element [ 'value' ]) To see how to use a custom converter to map into a StructBlock, see working with StructBlocks .","title":"Writing Custom Converters"},{"location":"flow/","text":"The Content Import Flow The Wagtail Content Import app provides: Pickers - which select and import raw document data Parsers - which parse the raw document data into a standard intermediate form Mappers - which convert this intermediate form into a final output (typically a Wagtail StreamField) The typical flow is as follows, for a Page model with ContentImportMixin : The Create view in the Wagtail Admin provides a button, which calls a picker. The picker enables a document to be selected, and makes a POST request to the Create view with the document data. The Wagtail hook for \"before_create_page\" in the picker detects the document, and calls a relevant parser. The parser's parse() method converts the raw document data to a list of {'type': type, 'value': value} elements. The create_page_from_import function is called, which in turn passes the parsed data to the Page model's create_from_import method (inherited from ContentImportMixin ). By default, this creates an instance of the Page's mapper_class , then uses its map() method to call a relevant Converter for each {'type': type, 'value': value} element. This returns a StreamField-compatible list of ('block_name', block_content) tuples. Finally a Page model instance is created (but not saved) with the document's title, and the content inserted into a field called body . The Create view is then rendered with the Page model instance bound to the form.","title":"The Content Import Flow"},{"location":"flow/#the-content-import-flow","text":"The Wagtail Content Import app provides: Pickers - which select and import raw document data Parsers - which parse the raw document data into a standard intermediate form Mappers - which convert this intermediate form into a final output (typically a Wagtail StreamField) The typical flow is as follows, for a Page model with ContentImportMixin : The Create view in the Wagtail Admin provides a button, which calls a picker. The picker enables a document to be selected, and makes a POST request to the Create view with the document data. The Wagtail hook for \"before_create_page\" in the picker detects the document, and calls a relevant parser. The parser's parse() method converts the raw document data to a list of {'type': type, 'value': value} elements. The create_page_from_import function is called, which in turn passes the parsed data to the Page model's create_from_import method (inherited from ContentImportMixin ). By default, this creates an instance of the Page's mapper_class , then uses its map() method to call a relevant Converter for each {'type': type, 'value': value} element. This returns a StreamField-compatible list of ('block_name', block_content) tuples. Finally a Page model instance is created (but not saved) with the document's title, and the content inserted into a field called body . The Create view is then rendered with the Page model instance bound to the form.","title":"The Content Import Flow"},{"location":"getting_started/","text":"Requirements: Django 2.2 Wagtail 2.2 To set up: Run python3 pip install wagtail-content-import . Add 'wagtail_content_import' to INSTALLED_APPS above wagtail.admin Add the urls: include wagtail_import.urls in your urlpatterns in urls.py . This could look like: from django.urls import include , path from wagtail_content_import import urls as wagtail_content_import_urls urlpatterns += [ path ( '' , include ( wagtail_content_import_urls )), ] Note that wagtail_content_import.urls must be above wagtail.core.urls in your urlpatterns . Add the relevant pickers: To import from Google Docs, add 'wagtail_content_import.pickers.google' to INSTALLED_APPS above wagtail.admin , then follow the steps given in Google Docs Setup To import from OneDrive/SharePoint, add 'wagtail_content_import.pickers.microsoft' to INSTALLED_APPS above wagtail.admin , then follow the steps given in Microsoft Setup To import from local files, add 'wagtail_content_import.pickers.local' to INSTALLED_APPS above wagtail.admin , You're now ready to set up how content will be imported to your Page models: see Basic Usage","title":"Basic Setup"},{"location":"getting_started/#requirements","text":"Django 2.2 Wagtail 2.2","title":"Requirements:"},{"location":"getting_started/#to-set-up","text":"Run python3 pip install wagtail-content-import . Add 'wagtail_content_import' to INSTALLED_APPS above wagtail.admin Add the urls: include wagtail_import.urls in your urlpatterns in urls.py . This could look like: from django.urls import include , path from wagtail_content_import import urls as wagtail_content_import_urls urlpatterns += [ path ( '' , include ( wagtail_content_import_urls )), ] Note that wagtail_content_import.urls must be above wagtail.core.urls in your urlpatterns . Add the relevant pickers: To import from Google Docs, add 'wagtail_content_import.pickers.google' to INSTALLED_APPS above wagtail.admin , then follow the steps given in Google Docs Setup To import from OneDrive/SharePoint, add 'wagtail_content_import.pickers.microsoft' to INSTALLED_APPS above wagtail.admin , then follow the steps given in Microsoft Setup To import from local files, add 'wagtail_content_import.pickers.local' to INSTALLED_APPS above wagtail.admin , You're now ready to set up how content will be imported to your Page models: see Basic Usage","title":"To set up:"},{"location":"google_docs_setup/","text":"Setting Up Google Integration Wagtail Google Docs integration relies on Google APIs, which you will first need to enable for your project: Navigate to the Google API Library . Select a project for your Wagtail site, or create a new one now. Find and enable the Google Docs and Google Drive APIs. Find and enable the Google Picker API, and copy its API key to the setting WAGTAILCONTENTIMPORT_GOOGLE_PICKER_API_KEY . Open the Credentials page in the API Console. Select Create credentials , then OAuth client ID If you haven't already configured the consent screen, you will need to configure this now. Under Scopes for Google APIs , click Add scope . Add ../auth/documents.readonly and ../auth/drive.readonly scopes. Note: adding these sensitive scopes means that you will need to submit your project for verification by Google to avoid user caps and warning pages during use. Add your domain to Authorised domains . For Application type , choose Web application Under Authorised JavaScript origins , add your domain. On the Credentials page, next to your Client ID, click the download item to download a JSON file of your client secret. Copy the text from this file, and use it to set WAGTAILCONTENTIMPORT_GOOGLE_OAUTH_CLIENT_CONFIG . Note For users to authenticate with Google and import documents from their Drives, they must either allow third party cookies or add accounts.google.com to their allowed domains ( Settings/Privacy and Security/Cookies and other site data in Chrome or Preferences/Privacy & Security in Firefox ).","title":"Google Docs Setup"},{"location":"google_docs_setup/#setting-up-google-integration","text":"Wagtail Google Docs integration relies on Google APIs, which you will first need to enable for your project: Navigate to the Google API Library . Select a project for your Wagtail site, or create a new one now. Find and enable the Google Docs and Google Drive APIs. Find and enable the Google Picker API, and copy its API key to the setting WAGTAILCONTENTIMPORT_GOOGLE_PICKER_API_KEY . Open the Credentials page in the API Console. Select Create credentials , then OAuth client ID If you haven't already configured the consent screen, you will need to configure this now. Under Scopes for Google APIs , click Add scope . Add ../auth/documents.readonly and ../auth/drive.readonly scopes. Note: adding these sensitive scopes means that you will need to submit your project for verification by Google to avoid user caps and warning pages during use. Add your domain to Authorised domains . For Application type , choose Web application Under Authorised JavaScript origins , add your domain. On the Credentials page, next to your Client ID, click the download item to download a JSON file of your client secret. Copy the text from this file, and use it to set WAGTAILCONTENTIMPORT_GOOGLE_OAUTH_CLIENT_CONFIG .","title":"Setting Up Google Integration"},{"location":"google_docs_setup/#note","text":"For users to authenticate with Google and import documents from their Drives, they must either allow third party cookies or add accounts.google.com to their allowed domains ( Settings/Privacy and Security/Cookies and other site data in Chrome or Preferences/Privacy & Security in Firefox ).","title":"Note"},{"location":"microsoft_setup/","text":"Setting Up OneDrive/SharePoint Integration Wagtail OneDrive/SharePoint integration relies on Microsoft APIs, which you will first need to enable for your project: Navigate to the Microsoft Azure app registrations page If you don't have a registration for your project, create a new registration now. Either while creating your registration, or by selecting your project and navigating to Authentication , add a new redirect URI : If you have included wagtail_content_import.urls as follows: url(r'ADDITIONAL_URL_PATH/', include(wagtail_content_import_urls)) The redirect URI will be: https://BASE_URL/ADDITIONAL_URL_PATH/microsoft/auth/ (substituting BASE_URL for your site's url, and ADDITIONAL_URL_PATH for the path under which you have included wagtail_content_import.urls ) Navigate to Authentication . Under Implicit grant , add Access tokens and ID tokens , and save. Finally, navigate to Overview , and copy the Application (client) ID into the WAGTAILCONTENTIMPORT_MICROSOFT_CLIENT_ID setting.","title":"Microsoft Setup"},{"location":"microsoft_setup/#setting-up-onedrivesharepoint-integration","text":"Wagtail OneDrive/SharePoint integration relies on Microsoft APIs, which you will first need to enable for your project: Navigate to the Microsoft Azure app registrations page If you don't have a registration for your project, create a new registration now. Either while creating your registration, or by selecting your project and navigating to Authentication , add a new redirect URI : If you have included wagtail_content_import.urls as follows: url(r'ADDITIONAL_URL_PATH/', include(wagtail_content_import_urls)) The redirect URI will be: https://BASE_URL/ADDITIONAL_URL_PATH/microsoft/auth/ (substituting BASE_URL for your site's url, and ADDITIONAL_URL_PATH for the path under which you have included wagtail_content_import.urls ) Navigate to Authentication . Under Implicit grant , add Access tokens and ID tokens , and save. Finally, navigate to Overview , and copy the Application (client) ID into the WAGTAILCONTENTIMPORT_MICROSOFT_CLIENT_ID setting.","title":"Setting Up OneDrive/SharePoint Integration"},{"location":"release_notes/","text":"Release Notes Version 0.8.0 (19/5/2022) Feature: Wagtail 3.0 and Django 4.0 support Feature: Links matching internal pages in rich text are now automatically converted to page links Upgrade consideration: Wagtail versions below 2.11 are no longer supported Version 0.7.0 (19/4/2022) Fix: Importing empty paragraph elements from Google Docs (now included in the serialized format) no longer fails. Version 0.6.0 (11/11/2021) Feature: Wagtail Content Import now tries to identify if an imported image already exists in your library, and if so, reuses the existing image instead. Version 0.5.0 (03/08/2021) Feature: The import button has been added to the page editor on existing pages, allowing editors to update them with imported content. Upgrade consideration: Picker trigger event If you have created a custom picker, you should update the event that it uses to trigger it to open. Previously, pickers listened for the 'click' event on the import button but we have now added a new event called 'openPicker'. For example: document . addEventListener ( 'DOMContentLoaded' , function () { document . querySelectorAll ( '[data-content-import-picker=\" my_picker \"]' ). forEach ( function ( element ) { // ... element . addEventListener ( 'click' , function () { // <----- Change this from 'click' to 'openPicker' // ... }); }); }); See: Submitting a new backend Upgrade consideration: Customised .create_from_import() method If you have customised the .create_from_import() method on any page, you should replace this with a customisation of .update_from_import() instead. This will allow your customisation to work when the page is being updated or created. See: Changing Import Fields Version 0.4.2 (10/11/2020) Fix: Wagtail 2.11 compatibility Version 0.4.1 (16/04/2020) Fix: include templates for local picker Version 0.4.0 (16/04/2020) Feature: an additional picker allowing docx import from local files is now included. To use it, add wagtail_content_import.pickers.local to INSTALLED_APPS above wagtail.admin . Version 0.3.3 (04/03/2020) Fix: Google documents with nested or multiple text styles are now parsed correctly Version 0.3.2 (03/03/2020) Update: GoogleDocumentsParser parser now parses underline, superscript, subscript, and strikethrough styles. (Note that using nonstandard rich text features requires adding them to both the RichTextConverter class and the RichTextField or block) Update: RichTextConverter now uses the Draftail ContentstateConverter to validate imported content, so correctly accepts features available in Draftail but not Hallo.js Update: GoogleDocumentsParser now converts heading styles in Google Docs more straightforwardly to html tags. For example, HEADING_2 maps to h2 tags. Version 0.3.1 (27/02/2020) Update: settings for pickers are now prefixed with WAGTAILCONTENTIMPORT_ for consistency, so the names are now WAGTAILCONTENTIMPORT_GOOGLE_PICKER_API_KEY , WAGTAILCONTENTIMPORT_GOOGLE_OAUTH_CLIENT_CONFIG and WAGTAILCONTENTIMPORT_MICROSOFT_CLIENT_ID . Make sure to change these when updating! Version 0.3.0 (26/02/2020) Fix: settings for pickers will no longer cause errors in the edit view when unset or set to blank strings - instead, pickers will hide themselves. Update: settings for pickers are now prefixed with WAGTAIL_CONTENT_IMPORT_ , so the names are now WAGTAIL_CONTENT_IMPORT_GOOGLE_PICKER_API_KEY , WAGTAIL_CONTENT_IMPORT_GOOGLE_OAUTH_CLIENT_CONFIG and WAGTAIL_CONTENT_IMPORT_MICROSOFT_CLIENT_ID . Make sure to change these when updating!","title":"Release Notes"},{"location":"release_notes/#release-notes","text":"","title":"Release Notes"},{"location":"release_notes/#version-080-1952022","text":"Feature: Wagtail 3.0 and Django 4.0 support Feature: Links matching internal pages in rich text are now automatically converted to page links Upgrade consideration: Wagtail versions below 2.11 are no longer supported","title":"Version 0.8.0 (19/5/2022)"},{"location":"release_notes/#version-070-1942022","text":"Fix: Importing empty paragraph elements from Google Docs (now included in the serialized format) no longer fails.","title":"Version 0.7.0 (19/4/2022)"},{"location":"release_notes/#version-060-11112021","text":"Feature: Wagtail Content Import now tries to identify if an imported image already exists in your library, and if so, reuses the existing image instead.","title":"Version 0.6.0 (11/11/2021)"},{"location":"release_notes/#version-050-03082021","text":"Feature: The import button has been added to the page editor on existing pages, allowing editors to update them with imported content. Upgrade consideration: Picker trigger event If you have created a custom picker, you should update the event that it uses to trigger it to open. Previously, pickers listened for the 'click' event on the import button but we have now added a new event called 'openPicker'. For example: document . addEventListener ( 'DOMContentLoaded' , function () { document . querySelectorAll ( '[data-content-import-picker=\" my_picker \"]' ). forEach ( function ( element ) { // ... element . addEventListener ( 'click' , function () { // <----- Change this from 'click' to 'openPicker' // ... }); }); }); See: Submitting a new backend Upgrade consideration: Customised .create_from_import() method If you have customised the .create_from_import() method on any page, you should replace this with a customisation of .update_from_import() instead. This will allow your customisation to work when the page is being updated or created. See: Changing Import Fields","title":"Version 0.5.0 (03/08/2021)"},{"location":"release_notes/#version-042-10112020","text":"Fix: Wagtail 2.11 compatibility","title":"Version 0.4.2 (10/11/2020)"},{"location":"release_notes/#version-041-16042020","text":"Fix: include templates for local picker","title":"Version 0.4.1 (16/04/2020)"},{"location":"release_notes/#version-040-16042020","text":"Feature: an additional picker allowing docx import from local files is now included. To use it, add wagtail_content_import.pickers.local to INSTALLED_APPS above wagtail.admin .","title":"Version 0.4.0 (16/04/2020)"},{"location":"release_notes/#version-033-04032020","text":"Fix: Google documents with nested or multiple text styles are now parsed correctly","title":"Version 0.3.3 (04/03/2020)"},{"location":"release_notes/#version-032-03032020","text":"Update: GoogleDocumentsParser parser now parses underline, superscript, subscript, and strikethrough styles. (Note that using nonstandard rich text features requires adding them to both the RichTextConverter class and the RichTextField or block) Update: RichTextConverter now uses the Draftail ContentstateConverter to validate imported content, so correctly accepts features available in Draftail but not Hallo.js Update: GoogleDocumentsParser now converts heading styles in Google Docs more straightforwardly to html tags. For example, HEADING_2 maps to h2 tags.","title":"Version 0.3.2 (03/03/2020)"},{"location":"release_notes/#version-031-27022020","text":"Update: settings for pickers are now prefixed with WAGTAILCONTENTIMPORT_ for consistency, so the names are now WAGTAILCONTENTIMPORT_GOOGLE_PICKER_API_KEY , WAGTAILCONTENTIMPORT_GOOGLE_OAUTH_CLIENT_CONFIG and WAGTAILCONTENTIMPORT_MICROSOFT_CLIENT_ID . Make sure to change these when updating!","title":"Version 0.3.1 (27/02/2020)"},{"location":"release_notes/#version-030-26022020","text":"Fix: settings for pickers will no longer cause errors in the edit view when unset or set to blank strings - instead, pickers will hide themselves. Update: settings for pickers are now prefixed with WAGTAIL_CONTENT_IMPORT_ , so the names are now WAGTAIL_CONTENT_IMPORT_GOOGLE_PICKER_API_KEY , WAGTAIL_CONTENT_IMPORT_GOOGLE_OAUTH_CLIENT_CONFIG and WAGTAIL_CONTENT_IMPORT_MICROSOFT_CLIENT_ID . Make sure to change these when updating!","title":"Version 0.3.0 (26/02/2020)"},{"location":"settings/","text":"General Settings WAGTAILCONTENTIMPORT_DEFAULT_MAPPER : The Mapper class used by default for Page models with ContentImportMixin, unless mapper_class is overridden. Defaults to StreamFieldMapper. WAGTAILCONTENTIMPORT_GOOGLE_PARSER : The DocumentParser class used for Google Docs. Defaults to GoogleDocumentParser . WAGTAILCONTENTIMPORT_DOCX_PARSER : The DocumentParser class used for .docx files. Defaults to DocxParser . WAGTAILCONTENTIMPORT_CHECK_DUPLICATE_IMAGE_CONTENT : Whether Wagtail Content Import should check the file content as well as the hash when determining duplicate images. Defaults to False . WAGTAILCONTENTIMPORT_CONVERT_EXTERNAL_LINKS Whether Wagtail Content Import should automatically convert links that exactly match a page url to internal page links. Defaults to True . Google Picker Settings GOOGLE_OAUTH_CLIENT_CONFIG (Required): The app's Google client secret. (See: Google Docs Setup ) GOOGLE_PICKER_API_KEY (Required): The app's Google Picker API key, allowing selection of Google Docs. (See: Google Docs Setup ) Microsoft Picker Settings MICROSOFT_CLIENT_ID (Required): The app's Microsoft Azure client ID. (See: Microsoft Setup )","title":"Settings Reference"},{"location":"settings/#general-settings","text":"","title":"General Settings"},{"location":"settings/#wagtailcontentimport_default_mapper","text":"The Mapper class used by default for Page models with ContentImportMixin, unless mapper_class is overridden. Defaults to StreamFieldMapper.","title":"WAGTAILCONTENTIMPORT_DEFAULT_MAPPER:"},{"location":"settings/#wagtailcontentimport_google_parser","text":"The DocumentParser class used for Google Docs. Defaults to GoogleDocumentParser .","title":"WAGTAILCONTENTIMPORT_GOOGLE_PARSER:"},{"location":"settings/#wagtailcontentimport_docx_parser","text":"The DocumentParser class used for .docx files. Defaults to DocxParser .","title":"WAGTAILCONTENTIMPORT_DOCX_PARSER:"},{"location":"settings/#wagtailcontentimport_check_duplicate_image_content","text":"Whether Wagtail Content Import should check the file content as well as the hash when determining duplicate images. Defaults to False .","title":"WAGTAILCONTENTIMPORT_CHECK_DUPLICATE_IMAGE_CONTENT:"},{"location":"settings/#wagtailcontentimport_convert_external_links","text":"Whether Wagtail Content Import should automatically convert links that exactly match a page url to internal page links. Defaults to True .","title":"WAGTAILCONTENTIMPORT_CONVERT_EXTERNAL_LINKS"},{"location":"settings/#google-picker-settings","text":"","title":"Google Picker Settings"},{"location":"settings/#google_oauth_client_config-required","text":"The app's Google client secret. (See: Google Docs Setup )","title":"GOOGLE_OAUTH_CLIENT_CONFIG (Required):"},{"location":"settings/#google_picker_api_key-required","text":"The app's Google Picker API key, allowing selection of Google Docs. (See: Google Docs Setup )","title":"GOOGLE_PICKER_API_KEY (Required):"},{"location":"settings/#microsoft-picker-settings","text":"","title":"Microsoft Picker Settings"},{"location":"settings/#microsoft_client_id-required","text":"The app's Microsoft Azure client ID. (See: Microsoft Setup )","title":"MICROSOFT_CLIENT_ID (Required):"},{"location":"structblocks/","text":"To convert elements in the parsed document to a StructBlock, you'll need to write a custom converter (see Writing Custom Converters .) For a StructBlock, the converter output of a (self.block_name, content) tuple should provide content as a dict. For example, for a StructBlock: from wagtail.core.blocks import CharBlock , ChoiceBlock , StructBlock class HeadingBlock ( StructBlock ): \"\"\" Custom `StructBlock` that allows the user to select h2 - h4 sizes for headers \"\"\" heading_text = CharBlock ( classname = \"title\" , required = True ) size = ChoiceBlock ( choices = [ ( '' , 'Select a header size' ), ( 'h2' , 'H2' ), ( 'h3' , 'H3' ), ( 'h4' , 'H4' ) ], blank = True , required = False ) class Meta : icon = \"title\" template = \"blocks/heading_block.html\" content should be: { 'heading_text' : heading_text , 'size' : size , } To do this, we could write a converter: from wagtail_content_import.mappers.converters import BaseConverter class HeadingBlockConverter ( BaseConverter ): def __call__ ( self , element , ** kwargs ): return ( self . block_name , { 'heading_text' : element [ 'value' ], 'size' : 'h2' }) #A More Complex Example: A Custom ImageBlock For a custom ImageBlock: from django.utils.safestring import mark_safe from wagtail.core.blocks import BooleanBlock , StructBlock from wagtail.images.blocks import ImageChooserBlock class ImageBlock ( StructBlock ): show_full_image = BooleanBlock ( required = False ) image = ImageChooserBlock () class Meta : icon = \"image / picture\" admin_text = mark_safe ( \"<b>Image Block</b>\" ) label = \"Image Block\" template = \"pages/blocks/image_block.html\" In a StreamField: from wagtail.core.blocks import StreamBlock class BaseBodyStreamBlock ( StreamBlock ): image_block = ImageBlock () We can write a custom converter which borrows some of the functionality of ImageConverter : from wagtail_content_import.mappers.converters import BaseConverter , ImageConverter class ImageBlockConverter ( BaseConverter ): def __call__ ( self , element , user , * args , ** kwargs ): image_url = element [ 'value' ] image_name , image_content = ImageConverter . fetch_image ( image_url ) image = ImageConverter . import_as_image_model ( image_name , image_content , owner = user ) return ( self . block_name , { 'show_full_image' : None , 'image' : image })","title":"Working With StructBlocks"},{"location":"structblocks/#a-more-complex-example-a-custom-imageblock","text":"For a custom ImageBlock: from django.utils.safestring import mark_safe from wagtail.core.blocks import BooleanBlock , StructBlock from wagtail.images.blocks import ImageChooserBlock class ImageBlock ( StructBlock ): show_full_image = BooleanBlock ( required = False ) image = ImageChooserBlock () class Meta : icon = \"image / picture\" admin_text = mark_safe ( \"<b>Image Block</b>\" ) label = \"Image Block\" template = \"pages/blocks/image_block.html\" In a StreamField: from wagtail.core.blocks import StreamBlock class BaseBodyStreamBlock ( StreamBlock ): image_block = ImageBlock () We can write a custom converter which borrows some of the functionality of ImageConverter : from wagtail_content_import.mappers.converters import BaseConverter , ImageConverter class ImageBlockConverter ( BaseConverter ): def __call__ ( self , element , user , * args , ** kwargs ): image_url = element [ 'value' ] image_name , image_content = ImageConverter . fetch_image ( image_url ) image = ImageConverter . import_as_image_model ( image_name , image_content , owner = user ) return ( self . block_name , { 'show_full_image' : None , 'image' : image })","title":"#A More Complex Example: A Custom ImageBlock"},{"location":"submitting_backend/","text":"Thanks for being interested in contributing! All contributions should be submitted as pull requests to the Wagtail Content Import repository . Submitting a New Picker If you're planning on submitting a new picker - apps which enable choosing and importing a file from a remote source - you'll need to follow this blueprint: Overview and File Structure Inside wagtail_content_import.pickers , your app should have the following structure: my_picker static wagtail_content_import MY_PICKER.js templates wagtail_content_import MY_PICKER_js_init.html __init__.py apps.py utils.py wagtail_hooks.py Where MY_PICKER should be replaced with the name of your picker. MY_PICKER.js provides the JavaScript class for your picker, which will select a file and make a POST request to the page with relevant data using a hidden form MY_PICKER_js_init.html creates an instance of that class on the Create page, using a template filled in with the relevant settings, and sets up a listener to call that class's .show() method on clicking the relevant import button. __init__.py and apps.py set your app's name and label. utils.py adds your Python picker class, eg GooglePicker wagtail_hooks.py registers your picker using a Wagtail hook, and adds a before_create_page hook to actually take the POST-ed document data and import it, using a parser. The following examples will follow a picker which needs a variable AUTH_PARAMETERS available in the JavaScript in order to import content. MY_PICKER.js This adds the JavaScript class for your picker, and adds it to the window. It should implement a method to show the picker, and upon choosing, make a POST request to the page using a hidden form with relevant data that allows Wagtail to import the document: for the Google picker, this is a JSON containing the document; for the Microsoft picker, this is a temporary url allowing the file to be downloaded. Eg: ( function () { class MyPicker { constructor ( AUTH_PARAMETERS , importPageUrl , csrfToken ) { this . AUTH_PARAMETERS = AUTH_PARAMETERS ; this . importPageUrl = importPageUrl ; this . csrfToken = csrfToken ; } post_data ( response ) { // POST relevant data to the page // Use a hidden form so the browser reloads with the result of this request let form = document . createElement ( 'form' ); form . action = this . importPageUrl ; form . method = 'POST' ; form . style . visibility = 'hidden' ; document . body . appendChild ( form ); let csrfTokenField = document . createElement ( 'input' ); csrfTokenField . type = 'hidden' ; csrfTokenField . name = 'csrfmiddlewaretoken' ; csrfTokenField . value = this . csrfToken ; form . appendChild ( csrfTokenField ); let myDocField = document . createElement ( 'input' ); myDocField . type = 'hidden' ; myDocField . name = 'my-doc' ; myDocField . value = response . value ; form . appendChild ( myDocField ); form . submit (); } show () { # Open the picker here , and call this . post_data ( response ) on successfully getting a file } } window . MyPicker = MyPicker ; })(); MY_PICKER_js_init.html This should provide a Django template which creates an instance of your JS picker class, populated with the relevant variables, which can be filled in by the Django side using your Python picker class. It must also add a listener to the relevant import button, such that when it is clicked, it calls myPicker.show() . Eg: < script type = \"text/javascript\" > document . addEventListener ( 'DOMContentLoaded' , function () { document . querySelectorAll ( '[data-content-import-picker=\"my_picker\"]' ). forEach ( function ( element ) { let myPicker = new MyPicker ({{ AUTH_PARAMETERS }}, element . dataset . importPageUrl , '{{ csrf_token|escapejs }}' ); element . addEventListener ( 'openPicker' , function () { myPicker . show (); }); }); }); </ script > __init__.py and apps.py init.py : default_app_config = 'wagtail_content_import.pickers.my_picker.apps.WagtailContentImportMyPickerAppConfig' apps.py : from django.apps import AppConfig class WagtailContentImportMyPickerAppConfig ( AppConfig ): name = 'wagtail_content_import.pickers.my_picker' label = 'wagtail_content_import_my_picker' verbose_name = \"Wagtail Content Import - My Picker\" utils.py Here, you'll need to create the Python class for your new picker, which will provide the names and context needed by the js_init template. from django.template.loader import render_to_string from django.utils.safestring import mark_safe from wagtail_content_import.pickers import Picker class MyPicker ( Picker ): name = \"my_picker\" verbose_name = \"My Picker\" def __init__ ( self , AUTH_PARAMETERS ): self . AUTH_PARAMETERS = AUTH_PARAMETERS def get_context ( self ): return { 'picker' : self , 'AUTH_PARAMETERS' : self . AUTH_PARAMETERS , } js_template = 'wagtail_content_import/MY_PICKER_js_init.html' def render_js_init ( self , request ): return mark_safe ( render_to_string ( self . js_template , self . get_context (), request = request )) class Media : css = {} js = [ # ANY EXTRA JS YOU NEED HERE 'wagtail_content_import/MY_PICKER.js' , ] wagtail_hooks.py Finally, here you'll need to register your picker, and add a before create page hook to actually import posted content. Eg: from django.conf import settings from wagtail.core import hooks from .utils import MyPicker from ...utils import create_page_from_import , is_importing , set_importing @hooks . register ( \"before_create_page\" ) def create_from_my_doc ( request , parent_page , page_class ): if \"my-doc\" in request . POST and not is_importing ( request ): set_importing ( request ) parsed_doc = # PARSE THE DOCUMENT HERE return create_page_from_import ( request , parent_page , page_class , parsed_doc ) @hooks . register ( 'register_content_import_picker' ) def register_content_import_picker (): return MyPicker ( settings . AUTH_PARAMETERS , )","title":"Submitting a New Backend"},{"location":"submitting_backend/#submitting-a-new-picker","text":"If you're planning on submitting a new picker - apps which enable choosing and importing a file from a remote source - you'll need to follow this blueprint:","title":"Submitting a New Picker"},{"location":"submitting_backend/#overview-and-file-structure","text":"Inside wagtail_content_import.pickers , your app should have the following structure: my_picker static wagtail_content_import MY_PICKER.js templates wagtail_content_import MY_PICKER_js_init.html __init__.py apps.py utils.py wagtail_hooks.py Where MY_PICKER should be replaced with the name of your picker. MY_PICKER.js provides the JavaScript class for your picker, which will select a file and make a POST request to the page with relevant data using a hidden form MY_PICKER_js_init.html creates an instance of that class on the Create page, using a template filled in with the relevant settings, and sets up a listener to call that class's .show() method on clicking the relevant import button. __init__.py and apps.py set your app's name and label. utils.py adds your Python picker class, eg GooglePicker wagtail_hooks.py registers your picker using a Wagtail hook, and adds a before_create_page hook to actually take the POST-ed document data and import it, using a parser. The following examples will follow a picker which needs a variable AUTH_PARAMETERS available in the JavaScript in order to import content.","title":"Overview and File Structure"},{"location":"submitting_backend/#my_pickerjs","text":"This adds the JavaScript class for your picker, and adds it to the window. It should implement a method to show the picker, and upon choosing, make a POST request to the page using a hidden form with relevant data that allows Wagtail to import the document: for the Google picker, this is a JSON containing the document; for the Microsoft picker, this is a temporary url allowing the file to be downloaded. Eg: ( function () { class MyPicker { constructor ( AUTH_PARAMETERS , importPageUrl , csrfToken ) { this . AUTH_PARAMETERS = AUTH_PARAMETERS ; this . importPageUrl = importPageUrl ; this . csrfToken = csrfToken ; } post_data ( response ) { // POST relevant data to the page // Use a hidden form so the browser reloads with the result of this request let form = document . createElement ( 'form' ); form . action = this . importPageUrl ; form . method = 'POST' ; form . style . visibility = 'hidden' ; document . body . appendChild ( form ); let csrfTokenField = document . createElement ( 'input' ); csrfTokenField . type = 'hidden' ; csrfTokenField . name = 'csrfmiddlewaretoken' ; csrfTokenField . value = this . csrfToken ; form . appendChild ( csrfTokenField ); let myDocField = document . createElement ( 'input' ); myDocField . type = 'hidden' ; myDocField . name = 'my-doc' ; myDocField . value = response . value ; form . appendChild ( myDocField ); form . submit (); } show () { # Open the picker here , and call this . post_data ( response ) on successfully getting a file } } window . MyPicker = MyPicker ; })();","title":"MY_PICKER.js"},{"location":"submitting_backend/#my_picker_js_inithtml","text":"This should provide a Django template which creates an instance of your JS picker class, populated with the relevant variables, which can be filled in by the Django side using your Python picker class. It must also add a listener to the relevant import button, such that when it is clicked, it calls myPicker.show() . Eg: < script type = \"text/javascript\" > document . addEventListener ( 'DOMContentLoaded' , function () { document . querySelectorAll ( '[data-content-import-picker=\"my_picker\"]' ). forEach ( function ( element ) { let myPicker = new MyPicker ({{ AUTH_PARAMETERS }}, element . dataset . importPageUrl , '{{ csrf_token|escapejs }}' ); element . addEventListener ( 'openPicker' , function () { myPicker . show (); }); }); }); </ script >","title":"MY_PICKER_js_init.html"},{"location":"submitting_backend/#__init__py-and-appspy","text":"init.py : default_app_config = 'wagtail_content_import.pickers.my_picker.apps.WagtailContentImportMyPickerAppConfig' apps.py : from django.apps import AppConfig class WagtailContentImportMyPickerAppConfig ( AppConfig ): name = 'wagtail_content_import.pickers.my_picker' label = 'wagtail_content_import_my_picker' verbose_name = \"Wagtail Content Import - My Picker\"","title":"__init__.py and apps.py"},{"location":"submitting_backend/#utilspy","text":"Here, you'll need to create the Python class for your new picker, which will provide the names and context needed by the js_init template. from django.template.loader import render_to_string from django.utils.safestring import mark_safe from wagtail_content_import.pickers import Picker class MyPicker ( Picker ): name = \"my_picker\" verbose_name = \"My Picker\" def __init__ ( self , AUTH_PARAMETERS ): self . AUTH_PARAMETERS = AUTH_PARAMETERS def get_context ( self ): return { 'picker' : self , 'AUTH_PARAMETERS' : self . AUTH_PARAMETERS , } js_template = 'wagtail_content_import/MY_PICKER_js_init.html' def render_js_init ( self , request ): return mark_safe ( render_to_string ( self . js_template , self . get_context (), request = request )) class Media : css = {} js = [ # ANY EXTRA JS YOU NEED HERE 'wagtail_content_import/MY_PICKER.js' , ]","title":"utils.py"},{"location":"submitting_backend/#wagtail_hookspy","text":"Finally, here you'll need to register your picker, and add a before create page hook to actually import posted content. Eg: from django.conf import settings from wagtail.core import hooks from .utils import MyPicker from ...utils import create_page_from_import , is_importing , set_importing @hooks . register ( \"before_create_page\" ) def create_from_my_doc ( request , parent_page , page_class ): if \"my-doc\" in request . POST and not is_importing ( request ): set_importing ( request ) parsed_doc = # PARSE THE DOCUMENT HERE return create_page_from_import ( request , parent_page , page_class , parsed_doc ) @hooks . register ( 'register_content_import_picker' ) def register_content_import_picker (): return MyPicker ( settings . AUTH_PARAMETERS , )","title":"wagtail_hooks.py"}]}