{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Wagtail Content Import's Documentation","text":"<p>Wagtail Content Import is a module for importing page content into Wagtail from third-party sources.  Page content is imported into a StreamField, using a set of customisable mappings. Currently supports:</p>"},{"location":"#as-sources","title":"As sources:","text":"<ul> <li>Google Docs:</li> <li>OneDrive/SharePoint</li> </ul>"},{"location":"#as-files","title":"As files:","text":"<ul> <li>Google Docs documents with:<ul> <li>Rich text</li> <li>Tables</li> <li>Images</li> <li>Headings</li> </ul> </li> <li>Docx files with:<ul> <li>Text with bold and italics</li> <li>Headings</li> </ul> </li> </ul>"},{"location":"basic_usage/","title":"Basic Usage","text":"<ol> <li> <p>To enable import for a Page model, it should inherit from <code>ContentImportMixin</code> (<code>wagtail_content_import.models.ContentImportMixin</code>). By default, content will be imported into into a StreamField called <code>body</code> (see Changing Import Fields for how to change this).</p> </li> <li> <p>You'll then need to create a Mapper, which maps the parsed document into your StreamField blocks. Create a class deriving from <code>wagtail_content_import.mappers.streamfield.StreamFieldMapper</code>:</p> <pre><code>from wagtail_content_import.mappers.converters import ImageConverter, RichTextConverter, TableConverter, TextConverter\nfrom wagtail_content_import.mappers.streamfield import StreamFieldMapper\n\nclass MyMapper(StreamFieldMapper):\n    html = RichTextConverter('my_paragraph_block')\n    image = ImageConverter('my_image_block')\n    heading = TextConverter('my_heading_block')\n    table = TableConverter('my_table_block')\n</code></pre> <p>This would map to an example StreamField defined as:</p> <pre><code>from wagtail.images.blocks import ImageChooserBlock\nfrom wagtail.blocks import CharBlock, RichTextBlock, StreamBlock\nfrom wagtail.contrib.table_block.blocks import TableBlock\n\nclass BaseStreamBlock(StreamBlock):\n\"\"\"\n    Define the custom blocks that `StreamField` will utilize\n    \"\"\"\n    my_heading_block = CharBlock()\n    my_paragraph_block = RichTextBlock()\n    my_image_block = ImageChooserBlock()\n    my_table_block = TableBlock()\n</code></pre> <p>Note that the converters require the fields rather than the block classes: <code>'my_heading_block'</code>, not <code>CharBlock</code>.</p> <p>The above example assumes use of the simple blocks included with Wagtail. For StructBlocks, see Working with StructBlocks.</p> </li> <li> <p>Set <code>mapper_class</code> on your Page model to your new mapper class (or set <code>WAGTAILCONTENTIMPORT_DEFAULT_MAPPER</code> to your mapper use it for all imports by default).</p> </li> <li> <p>You should now see a button near the action menu when creating a new Page of your class in the admin, giving you the option to import a document.</p> </li> </ol>"},{"location":"changing_import_fields/","title":"Changing Import Fields","text":"<p>To change how the document's data is imported to the Page model - for example, importing to a StreamField other than <code>body</code>, you'll need to override the <code>update_from_import</code> method. On the <code>ContentImportMixin</code>, these are defined as:</p> <pre><code>from django.utils.text import slugify\n\nclass ContentImportMixin:\n    # ...\n\n    # Called whenever a page is created or updated from an import\n    # (note, when creating, self would be unsaved)\n    def update_from_import(self, parsed_doc, user):\n        self.title = parsed_doc[\"title\"]\n        self.slug = slugify(self.title)\n\n        mapper = self.mapper_class()\n        self.body = mapper.map(parsed_doc[\"elements\"], user=user)\n</code></pre> <p>To import into a different field, replace <code>body</code> with the name of your custom field.</p>"},{"location":"converter_reference/","title":"Converters","text":"<p>Converters are callable classes, which when called, take elements of the intermediate <code>{'type': type, 'value': value}</code> format (and keyword arguments) and return streamfield-compatible tuples of the <code>(block_name, block_content)</code> form. All converters inherit from <code>wagtail_content_import.mappers.converters.BaseConverter</code>, and take a <code>block_name</code> on init.</p>"},{"location":"converter_reference/#richtextconverterblock_name-featuresnone","title":"<code>RichTextConverter(block_name, features=None)</code>","text":"<p>Produces Draftail-compatible html suitable for a <code>RichTextBlock</code>, using either the features listed in <code>features</code> or the basic rich text features registered in the Wagtail feature registry (see the Wagtail documentation).</p>"},{"location":"converter_reference/#textconverterblock_name","title":"<code>TextConverter(block_name)</code>","text":"<p>Passes the element's <code>value</code> field directly through as the block content. Note that this must be escaped, as no whitelisting takes place.</p>"},{"location":"converter_reference/#imageconverterblock_name","title":"<code>ImageConverter(block_name)</code>","text":"<p>Imports an image found at the url given by the element's <code>value</code>, setting the title to the element's <code>title</code> if given, and the owner to the <code>user</code> kwarg if provided on calling, and returns the image as the block content.</p>"},{"location":"converter_reference/#tableconverterblock_name","title":"<code>TableConverter(block_name)</code>","text":"<p>Produces a text table from the intermediate table representation, compatible with <code>wagtail.contrib.table_block.blocks.TableBlock</code>.</p>"},{"location":"custom_converters/","title":"Writing Custom Converters","text":"<p>Converters are callable classes which convert <code>{type: type, 'value': value}</code> elements  in a parsed document to StreamField blocks. You can write your own custom converters to include functionality not in the core app: for example, working with StructBlocks.</p> <p>Converters should inherit from <code>wagtail_content_import.mappers.converters.BaseConverter</code>, which provides an <code>__init__</code> method which populates <code>self.block_name</code>, the field name of the StreamField block the converter is creating.</p> <p>Converters should implement a <code>__call__(self, element, **kwargs)</code> method which returns a  StreamField-compatible tuple of <code>(self.block_name, content)</code> for an <code>element</code> of the form <code>{type: type, 'value': value}</code></p> <p>For example, the default TextConverter is implemented simply as:</p> <pre><code>from wagtail_content_import.parsers.converters import BaseConverter\n\nclass TextConverter(BaseConverter):\n    def __call__(self, element, **kwargs):\n        return (self.block_name, element['value'])\n</code></pre> <p>To see how to use a custom converter to map into a StructBlock, see working with StructBlocks.</p>"},{"location":"flow/","title":"The Content Import Flow","text":""},{"location":"flow/#the-content-import-flow","title":"The Content Import Flow","text":"<p>The Wagtail Content Import app provides:</p> <ul> <li>Pickers - which select and import raw document data </li> <li>Parsers - which parse the raw document data into a standard intermediate form</li> <li>Mappers - which convert this intermediate form into a final output (typically a Wagtail StreamField)</li> </ul> <p>The typical flow is as follows, for a <code>Page</code> model with <code>ContentImportMixin</code>:</p> <ol> <li> <p>The <code>Create</code> view in the Wagtail Admin provides a button, which calls a picker.</p> </li> <li> <p>The picker enables a document to be selected, and makes a POST request to the <code>Create</code> view with the document data.</p> </li> <li> <p>The Wagtail hook for <code>\"before_create_page\"</code> in the picker detects the document, and calls a relevant parser.</p> </li> <li> <p>The parser's <code>parse()</code> method converts the raw document data to a list of <code>{'type': type, 'value': value}</code> elements.</p> </li> <li> <p>The <code>create_page_from_import</code> function is called, which in turn passes the parsed data to the Page model's  <code>create_from_import</code> method (inherited from <code>ContentImportMixin</code>).</p> </li> <li> <p>By default, this creates an instance of the Page's <code>mapper_class</code>, then uses its <code>map()</code> method to call a relevant Converter for each <code>{'type': type, 'value': value}</code> element. This returns a StreamField-compatible list of  <code>('block_name', block_content)</code> tuples.</p> </li> <li> <p>Finally a <code>Page</code> model instance is created (but not saved) with the document's title, and the content inserted into a field called <code>body</code>. </p> </li> <li> <p>The <code>Create</code> view is then rendered with the <code>Page</code> model instance bound to the form.</p> </li> </ol>"},{"location":"getting_started/","title":"Basic Setup","text":""},{"location":"getting_started/#requirements","title":"Requirements:","text":"<ul> <li>Django 2.2</li> <li>Wagtail 2.2</li> </ul>"},{"location":"getting_started/#to-set-up","title":"To set up:","text":"<ol> <li>Run <code>python3 pip install wagtail-content-import</code>.</li> <li>Add <code>'wagtail_content_import'</code> to <code>INSTALLED_APPS</code> above <code>wagtail.admin</code></li> <li> <p>Add the urls: include <code>wagtail_import.urls</code> in your <code>urlpatterns</code> in <code>urls.py</code>. This could look like:</p> <pre><code>from django.urls import include, path\nfrom wagtail_content_import import urls as wagtail_content_import_urls\nurlpatterns += [\n    path('', include(wagtail_content_import_urls)),\n    ]\n</code></pre> <p>Note that <code>wagtail_content_import.urls</code> must be above <code>wagtail.urls</code> in your <code>urlpatterns</code>.</p> </li> <li> <p>Add the relevant pickers:</p> <ul> <li>To import from Google Docs, add<code>'wagtail_content_import.pickers.google'</code> to <code>INSTALLED_APPS</code> above <code>wagtail.admin</code>,   then follow the steps given in Google Docs Setup</li> <li>To import from OneDrive/SharePoint, add<code>'wagtail_content_import.pickers.microsoft'</code> to <code>INSTALLED_APPS</code> above <code>wagtail.admin</code>,   then follow the steps given in Microsoft Setup</li> <li>To import from local files, add<code>'wagtail_content_import.pickers.local'</code> to <code>INSTALLED_APPS</code> above <code>wagtail.admin</code>,</li> </ul> </li> <li> <p>You're now ready to set up how content will be imported to your Page models: see Basic Usage</p> </li> </ol>"},{"location":"google_docs_setup/","title":"Setting Up Google Integration","text":"<p>Wagtail Google Docs integration relies on Google APIs, which you will first need to enable for your project:</p> <ol> <li> <p>Navigate to the Google API Library. Select a project for your Wagtail site, or create a new one now.</p> </li> <li> <p>Find and enable the Google Docs and Google Drive APIs.</p> </li> <li> <p>Find and enable the Google Picker API, and copy its API key to the setting <code>WAGTAILCONTENTIMPORT_GOOGLE_PICKER_API_KEY</code>.</p> </li> <li> <p>Open the Credentials page in the API Console.</p> </li> <li> <p>Select <code>Create credentials</code>, then <code>OAuth client ID</code></p> </li> <li> <p>If you haven't already configured the consent screen, you will need to configure this now.</p> <ol> <li> <p>Under <code>Scopes for Google APIs</code>, click <code>Add scope</code>.</p> </li> <li> <p>Add <code>../auth/documents.readonly</code> and <code>../auth/drive.readonly</code> scopes.</p> <p>Note: adding these sensitive scopes means that you will need to submit your project for verification by Google to avoid user caps and warning pages during use.</p> </li> <li> <p>Add your domain to <code>Authorised domains</code>.</p> </li> </ol> </li> <li> <p>For <code>Application type</code>, choose <code>Web application</code></p> </li> <li> <p>Under <code>Authorised JavaScript origins</code>, add your domain.</p> </li> <li> <p>On the Credentials page, next to your Client ID, click the download item to download a JSON file of your client     secret.</p> </li> <li> <p>Copy the text from this file, and use it to set <code>WAGTAILCONTENTIMPORT_GOOGLE_OAUTH_CLIENT_CONFIG</code>.</p> </li> </ol>"},{"location":"google_docs_setup/#note","title":"Note","text":"<p>For users to authenticate with Google and import documents from their Drives, they must either allow third party cookies or add <code>accounts.google.com</code> to their allowed domains (Settings/Privacy and Security/Cookies and other site data in Chrome or Preferences/Privacy &amp; Security in Firefox).</p>"},{"location":"microsoft_setup/","title":"Setting Up OneDrive/SharePoint Integration","text":"<p>Wagtail OneDrive/SharePoint integration relies on Microsoft APIs, which you will first need to enable for your project:</p> <ol> <li> <p>Navigate to the Microsoft Azure app registrations page</p> </li> <li> <p>If you don't have a registration for your project, create a new registration now.</p> </li> <li> <p>Either while creating your registration, or by selecting your project and navigating to <code>Authentication</code>, add a new <code>redirect URI</code>:</p> <p>If you have included <code>wagtail_content_import.urls</code> as follows:</p> <pre><code>url(r'ADDITIONAL_URL_PATH/', include(wagtail_content_import_urls))\n</code></pre> </li> </ol> <p>The redirect URI will be: <code>https://BASE_URL/ADDITIONAL_URL_PATH/microsoft/auth/</code>    (substituting BASE_URL for your site's url, and ADDITIONAL_URL_PATH for the path under which you have included <code>wagtail_content_import.urls</code>)</p> <ol> <li> <p>Navigate to <code>Authentication</code>. Under <code>Implicit grant</code>, add <code>Access tokens</code> and <code>ID tokens</code>, and save.</p> </li> <li> <p>Finally, navigate to <code>Overview</code>, and copy the <code>Application (client) ID</code> into the <code>WAGTAILCONTENTIMPORT_MICROSOFT_CLIENT_ID</code> setting.</p> </li> </ol>"},{"location":"release_notes/","title":"Release Notes","text":""},{"location":"release_notes/#version-092-642023","title":"Version 0.9.2 (6/4/2023)","text":"<ul> <li>Wagtail 4.2.2 support, fixing a bug that prevented image import due to a change in function signature</li> </ul>"},{"location":"release_notes/#version-090-1722023","title":"Version 0.9.0 (17/2/2023)","text":"<ul> <li>Wagtail 4.2 support, drop support for versions &lt; 4.1</li> </ul>"},{"location":"release_notes/#version-081-1722023","title":"Version 0.8.1 (17/2/2023)","text":"<ul> <li>Wagtail 4 support</li> </ul>"},{"location":"release_notes/#version-080-1952022","title":"Version 0.8.0 (19/5/2022)","text":"<ul> <li>Feature: Wagtail 3.0 and Django 4.0 support</li> <li>Feature: Links matching internal pages in rich text are now automatically converted to page links</li> <li>Upgrade consideration: Wagtail versions below 2.11 are no longer supported</li> </ul>"},{"location":"release_notes/#version-070-1942022","title":"Version 0.7.0 (19/4/2022)","text":"<ul> <li>Fix: Importing empty paragraph elements from Google Docs (now included in the serialized format) no longer fails.</li> </ul>"},{"location":"release_notes/#version-060-11112021","title":"Version 0.6.0 (11/11/2021)","text":"<ul> <li>Feature: Wagtail Content Import now tries to identify if an imported image already exists in your library, and if so, reuses the existing image instead.</li> </ul>"},{"location":"release_notes/#version-050-03082021","title":"Version 0.5.0 (03/08/2021)","text":"<ul> <li> <p>Feature: The import button has been added to the page editor on existing pages, allowing editors to update them with imported content.</p> </li> <li> <p>Upgrade consideration: Picker trigger event</p> <p>If you have created a custom picker, you should update the event that it uses to trigger it to open. Previously, pickers listened for the 'click' event on the import button but we have now added a new event called 'openPicker'.</p> <p>For example:</p> <pre><code>document.addEventListener('DOMContentLoaded', function() {\n  document.querySelectorAll('[data-content-import-picker=\"my_picker\"]').forEach(function (element) {\n    // ...\n\n    element.addEventListener('click', function() {  // &lt;----- Change this from 'click' to 'openPicker'\n      // ...\n    });\n  });\n});\n</code></pre> <p>See: Submitting a new backend</p> </li> <li> <p>Upgrade consideration: Customised <code>.create_from_import()</code> method</p> <p>If you have customised the <code>.create_from_import()</code> method on any page, you should replace this with a customisation of <code>.update_from_import()</code> instead. This will allow your customisation to work when the page is being updated or created.</p> <p>See: Changing Import Fields</p> </li> </ul>"},{"location":"release_notes/#version-042-10112020","title":"Version 0.4.2 (10/11/2020)","text":"<ul> <li>Fix: Wagtail 2.11 compatibility</li> </ul>"},{"location":"release_notes/#version-041-16042020","title":"Version 0.4.1 (16/04/2020)","text":"<ul> <li>Fix: include templates for local picker</li> </ul>"},{"location":"release_notes/#version-040-16042020","title":"Version 0.4.0 (16/04/2020)","text":"<ul> <li>Feature: an additional picker allowing <code>docx</code> import from local files is now included. To use it, add <code>wagtail_content_import.pickers.local</code> to   <code>INSTALLED_APPS</code> above <code>wagtail.admin</code>.</li> </ul>"},{"location":"release_notes/#version-033-04032020","title":"Version 0.3.3 (04/03/2020)","text":"<ul> <li>Fix: Google documents with nested or multiple text styles are now parsed correctly</li> </ul>"},{"location":"release_notes/#version-032-03032020","title":"Version 0.3.2 (03/03/2020)","text":"<ul> <li>Update: <code>GoogleDocumentsParser</code> parser now parses underline, superscript, subscript, and strikethrough styles. (Note that using nonstandard   rich text features requires adding them to both the <code>RichTextConverter</code> class and the <code>RichTextField</code> or block)</li> <li>Update: <code>RichTextConverter</code> now uses the Draftail <code>ContentstateConverter</code> to validate imported content, so correctly accepts features available in   Draftail but not Hallo.js</li> <li>Update: <code>GoogleDocumentsParser</code> now converts heading styles in Google Docs more straightforwardly to html tags. For example, <code>HEADING_2</code> maps to <code>h2</code> tags.</li> </ul>"},{"location":"release_notes/#version-031-27022020","title":"Version 0.3.1 (27/02/2020)","text":"<ul> <li>Update: settings for pickers are now prefixed with <code>WAGTAILCONTENTIMPORT_</code> for consistency, so the names are   now<code>WAGTAILCONTENTIMPORT_GOOGLE_PICKER_API_KEY</code>, <code>WAGTAILCONTENTIMPORT_GOOGLE_OAUTH_CLIENT_CONFIG</code> and <code>WAGTAILCONTENTIMPORT_MICROSOFT_CLIENT_ID</code>. Make sure to change these when updating!</li> </ul>"},{"location":"release_notes/#version-030-26022020","title":"Version 0.3.0 (26/02/2020)","text":"<ul> <li>Fix: settings for pickers will no longer cause errors in the edit view when unset or set to blank strings - instead, pickers will hide themselves.</li> <li>Update: settings for pickers are now prefixed with <code>WAGTAIL_CONTENT_IMPORT_</code>, so the names are now <code>WAGTAIL_CONTENT_IMPORT_GOOGLE_PICKER_API_KEY</code>,   <code>WAGTAIL_CONTENT_IMPORT_GOOGLE_OAUTH_CLIENT_CONFIG</code> and <code>WAGTAIL_CONTENT_IMPORT_MICROSOFT_CLIENT_ID</code>. Make sure to change these when updating!</li> </ul>"},{"location":"settings/","title":"Settings Reference","text":""},{"location":"settings/#general-settings","title":"General Settings","text":""},{"location":"settings/#wagtailcontentimport_default_mapper","title":"<code>WAGTAILCONTENTIMPORT_DEFAULT_MAPPER</code>:","text":"<p>The Mapper class used by default for Page models with ContentImportMixin, unless mapper_class is overridden. Defaults to StreamFieldMapper.</p>"},{"location":"settings/#wagtailcontentimport_google_parser","title":"<code>WAGTAILCONTENTIMPORT_GOOGLE_PARSER</code>:","text":"<p>The DocumentParser class used for Google Docs. Defaults to <code>GoogleDocumentParser</code>.</p>"},{"location":"settings/#wagtailcontentimport_docx_parser","title":"<code>WAGTAILCONTENTIMPORT_DOCX_PARSER</code>:","text":"<p>The DocumentParser class used for .docx files. Defaults to <code>DocxParser</code>.</p>"},{"location":"settings/#wagtailcontentimport_check_duplicate_image_content","title":"<code>WAGTAILCONTENTIMPORT_CHECK_DUPLICATE_IMAGE_CONTENT</code>:","text":"<p>Whether Wagtail Content Import should check the file content as well as the hash when determining duplicate images. Defaults to <code>False</code>.</p>"},{"location":"settings/#wagtailcontentimport_convert_external_links","title":"<code>WAGTAILCONTENTIMPORT_CONVERT_EXTERNAL_LINKS</code>","text":"<p>Whether Wagtail Content Import should automatically convert links that exactly match a page url to internal page links. Defaults to <code>True</code>.</p>"},{"location":"settings/#google-picker-settings","title":"Google Picker Settings","text":""},{"location":"settings/#google_oauth_client_config-required","title":"<code>GOOGLE_OAUTH_CLIENT_CONFIG</code> (Required):","text":"<p>The app's Google client secret. (See: Google Docs Setup)</p>"},{"location":"settings/#google_picker_api_key-required","title":"<code>GOOGLE_PICKER_API_KEY</code> (Required):","text":"<p>The app's Google Picker API key, allowing selection of Google Docs. (See: Google Docs Setup)</p>"},{"location":"settings/#microsoft-picker-settings","title":"Microsoft Picker Settings","text":""},{"location":"settings/#microsoft_client_id-required","title":"<code>MICROSOFT_CLIENT_ID</code> (Required):","text":"<p>The app's Microsoft Azure client ID. (See: Microsoft Setup)</p>"},{"location":"structblocks/","title":"Working With StructBlocks","text":"<p>To convert elements in the parsed document to a StructBlock, you'll need to write a custom converter (see Writing Custom Converters.)</p> <p>For a StructBlock, the converter output of a <code>(self.block_name, content)</code> tuple should provide <code>content</code> as a dict. For example, for a StructBlock:</p> <pre><code>from wagtail.blocks import CharBlock, ChoiceBlock, StructBlock\n\nclass HeadingBlock(StructBlock):\n\"\"\"\n    Custom `StructBlock` that allows the user to select h2 - h4 sizes for headers\n    \"\"\"\n    heading_text = CharBlock(classname=\"title\", required=True)\n    size = ChoiceBlock(choices=[\n        ('', 'Select a header size'),\n        ('h2', 'H2'),\n        ('h3', 'H3'),\n        ('h4', 'H4')\n    ], blank=True, required=False)\n\n    class Meta:\n        icon = \"title\"\n        template = \"blocks/heading_block.html\"\n</code></pre> <p><code>content</code> should be:</p> <pre><code>{\n    'heading_text': heading_text,\n    'size': size,\n}\n</code></pre> <p>To do this, we could write a converter:</p> <pre><code>from wagtail_content_import.mappers.converters import BaseConverter\n\nclass HeadingBlockConverter(BaseConverter):\n    def __call__(self, element, **kwargs):\n        return (self.block_name, {'heading_text': element['value'], 'size': 'h2'})\n</code></pre>"},{"location":"structblocks/#a-more-complex-example-a-custom-imageblock","title":"#A More Complex Example: A Custom ImageBlock","text":"<p>For a custom ImageBlock:</p> <pre><code>from django.utils.safestring import mark_safe\nfrom wagtail.blocks import BooleanBlock, StructBlock\nfrom wagtail.images.blocks import ImageChooserBlock\n\n\nclass ImageBlock(StructBlock):\n\n    show_full_image = BooleanBlock(required=False)\n    image = ImageChooserBlock()\n\n    class Meta:\n        icon = \"image / picture\"\n        admin_text = mark_safe(\"&lt;b&gt;Image Block&lt;/b&gt;\")\n        label = \"Image Block\"\n        template = \"pages/blocks/image_block.html\" \n</code></pre> <p>In a StreamField:</p> <pre><code>from wagtail.blocks import StreamBlock\n\nclass BaseBodyStreamBlock(StreamBlock):\n    image_block = ImageBlock()\n</code></pre> <p>We can write a custom converter which borrows some of the functionality of <code>ImageConverter</code>:</p> <pre><code>from wagtail_content_import.mappers.converters import BaseConverter, ImageConverter\n\nclass ImageBlockConverter(BaseConverter):\n    def __call__(self, element, user, *args, **kwargs):\n        image_url = element['value']\n        image_name, image_content = ImageConverter.fetch_image(image_url)\n        image = ImageConverter.import_as_image_model(image_name, image_content, owner=user)\n        return (self.block_name, {'show_full_image': None, 'image': image})\n</code></pre>"},{"location":"submitting_backend/","title":"Submitting a New Backend","text":"<p>Thanks for being interested in contributing! All contributions should be submitted as pull requests to the Wagtail Content Import repository.</p>"},{"location":"submitting_backend/#submitting-a-new-picker","title":"Submitting a New Picker","text":"<p>If you're planning on submitting a new picker - apps which enable choosing and importing a file from a remote source - you'll need to follow this blueprint:</p>"},{"location":"submitting_backend/#overview-and-file-structure","title":"Overview and File Structure","text":"<p>Inside <code>wagtail_content_import.pickers</code>, your app should have the following structure:</p> <ul> <li><code>my_picker</code><ul> <li><code>static</code><ul> <li><code>wagtail_content_import</code><ul> <li><code>MY_PICKER.js</code></li> </ul> </li> </ul> </li> <li><code>templates</code><ul> <li><code>wagtail_content_import</code><ul> <li><code>MY_PICKER_js_init.html</code></li> </ul> </li> </ul> </li> <li><code>__init__.py</code></li> <li><code>apps.py</code></li> <li><code>utils.py</code></li> <li><code>wagtail_hooks.py</code></li> </ul> </li> </ul> <p>Where <code>MY_PICKER</code> should be replaced with the name of your picker.</p> <ul> <li><code>MY_PICKER.js</code> provides the JavaScript class for your picker, which will select a file and make a POST request to the page with relevant data using a hidden form</li> <li><code>MY_PICKER_js_init.html</code> creates an instance of that class on the <code>Create</code> page, using   a template filled in with the relevant settings,   and sets up a listener to call that class's <code>.show()</code> method on clicking the relevant import   button.</li> <li><code>__init__.py</code> and <code>apps.py</code> set your app's name and label.</li> <li><code>utils.py</code> adds your Python picker class, eg <code>GooglePicker</code></li> <li><code>wagtail_hooks.py</code> registers your picker using a Wagtail hook, and adds a <code>before_create_page</code> hook to actually take the POST-ed document data and import it, using a parser.</li> </ul> <p>The following examples will follow a picker which needs a variable <code>AUTH_PARAMETERS</code> available in the JavaScript in order to import content.</p>"},{"location":"submitting_backend/#my_pickerjs","title":"<code>MY_PICKER.js</code>","text":"<p>This adds the JavaScript class for your picker, and adds it to the window. It should implement a method to show the picker, and upon choosing, make a POST request to the page using a hidden form with relevant data that allows Wagtail to import the document: for the Google picker, this is a JSON containing the document; for the Microsoft picker, this is a temporary url allowing the file to be downloaded.</p> <p>Eg:</p> <pre><code>(function() {\nclass MyPicker {\nconstructor(AUTH_PARAMETERS, importPageUrl, csrfToken) {\nthis.AUTH_PARAMETERS = AUTH_PARAMETERS;\nthis.importPageUrl = importPageUrl;\nthis.csrfToken = csrfToken;\n}\n\npost_data(response) {\n// POST relevant data to the page\n// Use a hidden form so the browser reloads with the result of this request\nlet form = document.createElement('form');\nform.action = this.importPageUrl;\nform.method = 'POST';\nform.style.visibility = 'hidden';\ndocument.body.appendChild(form);\n\nlet csrfTokenField = document.createElement('input');\ncsrfTokenField.type = 'hidden';\ncsrfTokenField.name = 'csrfmiddlewaretoken';\ncsrfTokenField.value = this.csrfToken;\nform.appendChild(csrfTokenField);\n\nlet myDocField = document.createElement('input');\nmyDocField.type = 'hidden';\nmyDocField.name = 'my-doc';\nmyDocField.value = response.value;\nform.appendChild(myDocField);\n\nform.submit();\n}\n\n\nshow() {\n# Open the picker here, and call this.post_data(response) on successfully getting a file\n}\n}\n\nwindow.MyPicker = MyPicker;\n})();\n</code></pre>"},{"location":"submitting_backend/#my_picker_js_inithtml","title":"<code>MY_PICKER_js_init.html</code>","text":"<p>This should provide a Django template which creates an instance of your JS picker class, populated with the relevant variables, which can be filled in by the Django side using your Python picker class. It must also add a listener to the relevant import button, such that when it is clicked, it calls <code>myPicker.show()</code>.</p> <p>Eg:</p> <pre><code>&lt;script type=\"text/javascript\"&gt;\ndocument.addEventListener('DOMContentLoaded', function() {\ndocument.querySelectorAll('[data-content-import-picker=\"my_picker\"]').forEach(function (element) {\nlet myPicker = new MyPicker({{ AUTH_PARAMETERS }}, element.dataset.importPageUrl, '{{ csrf_token|escapejs }}');\n\nelement.addEventListener('openPicker', function() {\nmyPicker.show();\n});\n});\n});\n&lt;/script&gt;\n</code></pre>"},{"location":"submitting_backend/#__init__py-and-appspy","title":"<code>__init__.py</code> and <code>apps.py</code>","text":"<p><code>init.py</code>:</p> <pre><code>default_app_config = 'wagtail_content_import.pickers.my_picker.apps.WagtailContentImportMyPickerAppConfig'\n</code></pre> <p><code>apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\n\nclass WagtailContentImportMyPickerAppConfig(AppConfig):\n    name = 'wagtail_content_import.pickers.my_picker'\n    label = 'wagtail_content_import_my_picker'\n    verbose_name = \"Wagtail Content Import - My Picker\"\n</code></pre>"},{"location":"submitting_backend/#utilspy","title":"<code>utils.py</code>","text":"<p>Here, you'll need to create the Python class for your new picker, which will provide the names and context needed by the <code>js_init</code> template.</p> <pre><code>from django.template.loader import render_to_string\nfrom django.utils.safestring import mark_safe\n\nfrom wagtail_content_import.pickers import Picker\n\n\nclass MyPicker(Picker):\n    name = \"my_picker\"\n    verbose_name = \"My Picker\"\n\n    def __init__(self, AUTH_PARAMETERS):\n        self.AUTH_PARAMETERS = AUTH_PARAMETERS\n\n    def get_context(self):\n        return {\n            'picker': self,\n            'AUTH_PARAMETERS': self.AUTH_PARAMETERS,\n        }\n\n    js_template = 'wagtail_content_import/MY_PICKER_js_init.html'\n\n    def render_js_init(self, request):\n        return mark_safe(render_to_string(self.js_template, self.get_context(), request=request))\n\n    class Media:\n        css = {}\n        js = [\n            # ANY EXTRA JS YOU NEED HERE\n            'wagtail_content_import/MY_PICKER.js',\n        ]\n</code></pre>"},{"location":"submitting_backend/#wagtail_hookspy","title":"<code>wagtail_hooks.py</code>","text":"<p>Finally, here you'll need to register your picker, and add a <code>before create page</code> hook to actually import posted content.</p> <p>Eg:</p> <pre><code>from django.conf import settings\n\nfrom wagtail import hooks\n\nfrom .utils import MyPicker\n\nfrom ...utils import create_page_from_import, is_importing, set_importing\n\n\n@hooks.register(\"before_create_page\")\ndef create_from_my_doc(request, parent_page, page_class):\n    if \"my-doc\" in request.POST and not is_importing(request):\n        set_importing(request)\n        parsed_doc = # PARSE THE DOCUMENT HERE\n        return create_page_from_import(request, parent_page, page_class, parsed_doc)\n\n\n@hooks.register('register_content_import_picker')\ndef register_content_import_picker():\n    return MyPicker(\n        settings.AUTH_PARAMETERS,\n    )\n</code></pre>"}]}